# lab5实验报告

这个报告要求比起之前几个报告还多加了一条，让我说说用了多少时间，我估计是写这个实验的助教因为各种原因，弄了很久很久很久吧。默哀。。。可是，可是这个算法真的不算很麻烦吧，应该一天能搞定吧。

## 需要修改的数据结构及需要添加的代码

src/task/process.rs/ProcessControlBlockInner

死锁检测是针对于每个进程的多个不同线程进行的，因此，需要在进程中添加任务中提到的几个数据结构，除此之外，由于需要开启和关闭死锁检测，因此还需要在其中加入变量表示是否已经开启，应当初始化为0。

(原本我以为写在process里面就行了，但是后来发现需要的代码太多，新开一个模块DL_detect放在sync文件夹下面了)

随后需要在new的时候，完成各个数据结构的初始化。

由于互斥锁可以看作信号量数量等于1的时候的特例，因此，以下描述仅仅只说信号量了。而且，在每个进程的控制块中，这两者应该都被视作某种资源。

向量 Available：是目前所有的信号量的数量构成的一个向量

Allocation矩阵：每个线程所占用的各种信号量的数量构成的矩阵

需求矩阵 Need：考虑到实际情况，如果某个线程需求的信号量得不到满足，一定会卡死在那个需求上面，而没有机会去申请别的信号量，而如果需求得到了满足，那么一定会在allocation上面增加一条，这个需求也不存在了。因此，这个需求矩阵一定是每个线程，在需求的那个信号量上面有1，其他全都是0，这样构成的一个矩阵。 

关于矩阵的动态扩充：当添加一个信号量，或者添加一个线程的时候，就需要动态扩充矩阵。同时，很明显他有结束向量，所以就没有缩减这个矩阵的需求了对吧。（算了，面向测例编程，直接开个大的二维数组算了，烦死了烦死了）

对于如何访问矩阵中的数据，横向是代表每个线程，直接有tid访问，而对于另一个维度的信号量，由于他们都被看作是某种资源，所以应该有统一的编号以便于访问。奈何mutex使用了多态，我也不敢瞎写，所以最后我决定了！使用一个骚操作，由于我开了个大数组（矩阵？），然后进程中也有mutex和semaphore的向量，因此，前半个数组映射到mutex向量，后半个数组映射到semaphore向量。

## 遇到的问题

我该如何实现一个可自己扩展的matrix库？

但凡这是个C。。。

我是用vec<vec<u32>>来试图~~逆天改命~~实现它，好在，我可耻的失败了。算了算了，面向测例编程吧。

