# lab2实验报告

## 需要修改的代码

### 重写 sys_get_time 和 sys_task_info

由于使用了虚拟地址，因此，这两个函数得到的参数，需要这两个函数参数指针的物理地址，并写入

对于该物理地址，手动查找页表获得参数指针所在的物理页表，然后和物理页表的最后12位进行或运算得到物理地址。

### mmap 和 munmap 匿名映射

对于这两个函数。需要在对应的任务的task ctr block中，新建一串映射。找到对应的任务控制块，添加一串地址到对应的task里面的memset里面。同时检查是否对应的块已经映射到某个虚拟块上面了

munmap则是相反的过程。这里面同样需要检查是否某个虚拟块已经映射过去了。

## 简答题

1/请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？

（这个明明在实验指导书上面写了，还要再来一遍，emm）

解答：

[63:54]	reserved

[53:10]	物理页号

[7:0]	标志位，分别为D，A，G，U，X，W，R，V

标志位的作用为：

-  V(Valid) 有效位；
- R/W/X 对应虚拟页面可读/写/执行权限；
- U U特权级下是否可以访问；
- G 表明这个映射是否对所有虚拟空间有效，一般用于下面说的单页表
- A(Accessed) 记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；
- D(Dirty) 则记录自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过。

2/缺页

缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程。

请问哪些异常可能是缺页导致的？

​		解答：

instruction page fault

load page fault

store page fault

发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。

​		解答：

八个控制状态寄存器(CSR)是机器模式下异常处理的必要部分:

- mtvec(MachineTrapVector)它保存发生异常时处理器需要跳转到的地址。

- mepc(Machine Exception PC)它指向发生异常的指令。

- mcause(Machine Exception Cause)它指示发生异常的种类。

- mie(Machine Interrupt Enable)它指出处理器目前能处理和必须忽略的中断。

- mip(Machine Interrupt Pending)它列出目前正准备处理的中断。

- mtval(Machine Trap Value)它保存了陷入(trap)的附加信息:地址例外中出错

  的地址、发生非法指令例外的指令本身，对于其他异常，它的值为 0。

- mscratch(Machine Scratch)它暂时存放一个字大小的数据。

- mstatus(Machine Status)它保存全局中断使能，以及许多其他的状态

缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做， 而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。

这样做有哪些好处？

​		解答：好处在于，不用一开始就把所有需要的内容都加载到内存中去，节省内存的使用和IO带宽

其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。

处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？

​		解答：10G/（2^9)

请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。

​		解答：实现lazy策略，除了需要映射内存之外，还需要在页面失效，被置换到磁盘上时，需要记录页面对应的磁盘块位置。当缺页时，根据页表项中，这个记录的磁盘位置，将磁盘上的块放入物理内存，修改pte完成虚拟内存到物理内存的映射。

缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。此时页面失效如何表现在页表项(PTE)上？

​		解答：有效位为0

3/双页表与单页表

为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 [KPTI](https://en.wikipedia.org/wiki/Kernel_page-table_isolation) )

- 在单页表情况下，如何更换页表？

  解答：在单页表情况下，内核地址在两个进程的页表中映射到同一个地址，因此，直接更改satp寄存器即可

- 单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问）

  解答：只允许内核态情况下访问内核页面，具体到实现，riscv更改页表项的权限位U

- 单页表有何优势？（回答合理即可）

  解答：单页表在进程陷入到内核态的时候，无需切换页表，而只有当进程发生切换的时候才需要更改页表。这会节省陷入内核态的消耗

- 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？

  解答：双页表实现情况，需要在用户态和内核态切换的时候进行更换页表。

  如果我写一个单页表操作系统，我会选择在内核态切换到另一个进程的时候进行切换

## 对该实验的看法和建议等等

没啥难度，但是有亮点，那个（虽然是自创的名称）单页表和双页表的设计，是我从来没有学到过的东西，值得肯定。
